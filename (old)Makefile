# AWS RAG Application Makefile
# 提供标准化的部署和管理命令

.PHONY: help install clean deploy destroy test lint check synth diff test-unit test-integration test-e2e test-coverage test-report

# 测试环境配置
test-env:
	@echo "🔍 环境配置测试"
	@echo "==============="
	@echo "AWS_REGION: $(AWS_REGION)"
	@echo "BEDROCK_MODEL_ID: $(BEDROCK_MODEL_ID)"
	@echo "EMBEDDING_MODEL_ID: $(EMBEDDING_MODEL_ID)"
	@echo "ZILLIZ_ENDPOINT: $(ZILLIZ_ENDPOINT)"
	@echo "ZILLIZ_TOKEN: $$(echo $(ZILLIZ_TOKEN) | cut -c1-10)..."
	@echo "==============="
	@echo "✅ 环境变量已正确加载！"

# 设置默认目标为deploy
.DEFAULT_GOAL := deploy

# 帮助信息
help:
	@echo "AWS RAG Application - 可用命令:"
	@echo ""
	@echo "📦 环境管理:"
	@echo "  make install      - 安装所有依赖"
	@echo "  make clean        - 清理构建产物和缓存"
	@echo "  make kill-cdk     - 终止所有CDK进程"
	@echo ""
	@echo "🧪 测试命令:"
	@echo "  make test         - 运行所有测试"
	@echo "  make test-unit    - 运行单元测试"
	@echo "  make test-integration - 运行集成测试"
	@echo "  make test-e2e     - 运行端到端测试"
	@echo "  make test-coverage - 生成覆盖率报告"
	@echo "  make test-report  - 生成测试报告"
	@echo "  make test-ui      - 运行UI测试"
	@echo ""
	@echo "🔍 代码质量:"
	@echo "  make lint         - 运行代码检查"
	@echo "  make type-check   - 运行类型检查"
	@echo "  make format       - 格式化代码"
	@echo ""
	@echo "☁️  部署管理:"
	@echo "  make deploy       - 部署应用到AWS"
	@echo "  make deploy-web   - 部署Web栈（修复CloudFront 403）"
	@echo "  make redeploy-web - 完全重新部署Web栈（彻底修复403）"
	@echo "  make fix-cloudfront - 修复CloudFront 403错误"
	@echo "  make verify-web   - 验证Web部署状态"
	@echo "  make destroy      - 销毁CDK管理的资源"
	@echo "  make destroy-all  - 完全清理所有AWS资源"
	@echo "  make synth        - 合成CDK模板"
	@echo "  make diff         - 查看栈差异"
	@echo "  make logs         - 查看Lambda日志"
	@echo ""
	@echo "🐳 Docker:"
	@echo "  make docker-build - 构建Docker镜像"
	@echo "  make docker-run   - 运行Docker容器"
	@echo "  make run-local    - 运行本地API服务器"
	@echo ""

# 环境变量检查
check-env:
	@if [ -z "$(ZILLIZ_ENDPOINT)" ]; then \
		echo "❌ ZILLIZ_ENDPOINT未设置"; \
		exit 1; \
	fi
	@if [ -z "$(ZILLIZ_TOKEN)" ]; then \
		echo "❌ ZILLIZ_TOKEN未设置"; \
		exit 1; \
	fi

# 安装依赖
install:
	@echo "安装Python依赖..."
	pip3 install -r requirements.txt
	pip3 install -r requirements-dev.txt
	@echo "安装测试依赖..."
	pip3 install -r tests/requirements-test.txt
	@echo "安装CDK..."
	npm install -g aws-cdk@latest
	cd infrastructure && pip3 install -r requirements.txt
	@echo "✅ 依赖安装完成"

# 清理
clean: kill-cdk
	@echo "清理构建产物..."
	find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	find . -type f -name "*.pyc" -delete
	find . -type d -name ".pytest_cache" -exec rm -rf {} + 2>/dev/null || true
	find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
	rm -rf infrastructure/cdk.out
	rm -rf htmlcov coverage.xml .coverage* coverage-*.xml
	rm -rf test-reports/
	rm -f /tmp/rag-deploy.lock
	@echo "✅ 清理完成"

# 终止CDK进程
kill-cdk:
	@echo "检查并终止CDK进程..."
	@ps aux | grep -E "(cdk|aws-cdk)" | grep -v grep | awk '{print $$2}' | xargs -r kill -9 2>/dev/null || true
	@docker ps -a | grep -E "(cdk|sam)" | awk '{print $$1}' | xargs -r docker stop 2>/dev/null || true
	@docker ps -a | grep -E "(cdk|sam)" | awk '{print $$1}' | xargs -r docker rm 2>/dev/null || true
	@echo "✅ CDK进程已清理"

# 代码检查
lint:
	@echo "运行代码格式化检查..."
	black --check app/ tests/
	isort --check-only app/ tests/
	flake8 app/ tests/
	@echo "✅ 代码检查通过"

# 代码格式化
format:
	@echo "格式化代码..."
	black app/ tests/
	isort app/ tests/
	@echo "✅ 代码格式化完成"

# 类型检查
type-check:
	@echo "运行类型检查..."
	mypy app/
	@echo "✅ 类型检查通过"

# 运行所有测试
test:
	@echo "运行所有测试..."
	pytest tests/ -v
	@echo "✅ 测试完成"

# 运行单元测试
test-unit:
	@echo "运行单元测试..."
	pytest tests/unit -v -m unit
	@echo "✅ 单元测试完成"

# 运行集成测试
test-integration:
	@echo "运行集成测试..."
	@chmod +x run_integration_tests.sh
	./run_integration_tests.sh
	@echo "✅ 集成测试完成"

# 运行端到端测试
test-e2e:
	@echo "运行端到端测试..."
	pytest tests/e2e -v -m e2e --tb=short
	@echo "✅ E2E测试完成"

# 运行UI测试
test-ui:
	@echo "运行UI测试..."
	@if [ -f "tests/run_ui_tests.sh" ]; then \
		chmod +x tests/run_ui_tests.sh && ./tests/run_ui_tests.sh; \
	else \
		pytest tests/test_ui*.py -v; \
	fi
	@echo "✅ UI测试完成"

# 生成覆盖率报告
test-coverage:
	@echo "生成测试覆盖率报告..."
	pytest tests/ --cov=app --cov-report=html:htmlcov --cov-report=term --cov-report=xml
	@echo "✅ 覆盖率报告已生成"
	@echo "📊 HTML报告: htmlcov/index.html"

# 生成测试报告
test-report:
	@echo "生成综合测试报告..."
	@python generate_test_report.py
	@echo "✅ 测试报告已生成"

# 快速测试（跳过慢速测试）
test-fast:
	@echo "运行快速测试（跳过慢速测试）..."
	pytest tests/ -v -m "not slow"
	@echo "✅ 快速测试完成"

# 测试监视模式
test-watch:
	@echo "启动测试监视模式..."
	pytest-watch tests/ -- -v

# CDK相关命令
STAGE ?= prod
AWS_REGION ?= us-east-1

# CDK Bootstrap（首次部署必需）
bootstrap:
	@echo "🚀 初始化CDK Bootstrap..."
	@echo "  区域: $(AWS_REGION)"
	@echo "  账号: $$(aws sts get-caller-identity --query Account --output text)"
	@echo ""
	@cd infrastructure && \
		CDK_DEFAULT_REGION=$(AWS_REGION) \
		CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) \
		AWS_DEFAULT_REGION=$(AWS_REGION) \
		npx cdk bootstrap aws://$$CDK_DEFAULT_ACCOUNT/$(AWS_REGION) --context stage=$(STAGE)
	@echo ""
	@echo "✅ CDK Bootstrap 完成！"
	@echo ""
	@echo "Bootstrap 已创建："
	@echo "  - S3 存储桶：cdk-hnb659fds-assets-*"
	@echo "  - IAM 角色：cdk-hnb659fds-*-role"
	@echo "  - SSM 参数：/cdk-bootstrap/hnb659fds/version"
	@echo ""
	@echo "现在可以运行 'make deploy' 部署应用"

# Bootstrap修复（解决AWS凭证和CDK Bootstrap问题）
fix-bootstrap:
	@echo "🔧 修复CDK Bootstrap..."
	@chmod +x fix_cdk_bootstrap.sh
	@./fix_cdk_bootstrap.sh
	@echo "✅ Bootstrap修复完成"

# 部署前检查
check: 
	@echo "🔍 执行部署前检查..."
	@chmod +x pre_deploy_check.sh
	@./pre_deploy_check.sh || (echo "❌ 检查失败，请先解决问题"; exit 1)
	@echo "✅ 所有检查通过"

# 合成模板
synth: clean
	@echo "合成CDK模板 (stage=$(STAGE))..."
	cd infrastructure && npx cdk synth --context stage=$(STAGE)
	@echo "✅ 模板合成完成"

# 查看差异
diff:
	@echo "查看栈差异 (stage=$(STAGE))..."
	cd infrastructure && npx cdk diff --context stage=$(STAGE)

# 打包Lambda函数
package-lambda:
	@echo "打包Lambda函数..."
	@if [ -f "package_lambda_optimized.sh" ]; then \
		echo "使用优化打包脚本..."; \
		chmod +x package_lambda_optimized.sh && ./package_lambda_optimized.sh; \
		if [ -f "lambda_deployment_optimized.zip" ]; then \
			mv lambda_deployment_optimized.zip lambda_deployment.zip; \
		fi; \
	else \
		echo "使用传统打包方式..."; \
		rm -rf lambda_deployment.zip; \
		cd lambda_functions && \
			pip3 install -r requirements.txt -t . --quiet && \
			zip -r ../lambda_deployment.zip . -x "*.pyc" -x "__pycache__/*" > /dev/null; \
	fi
	@echo "✅ Lambda函数打包完成 (lambda_deployment.zip)"

# 部署Web栈（修复CloudFront 403问题）
deploy-web: check-env
	@echo "🚀 部署Web栈（修复版）..."
	@echo "使用正确的S3 REST端点和OAI配置避免CloudFront 403错误"
	@echo ""
	@echo "1. 获取AWS账号信息..."
	@ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text) && \
	BUCKET_NAME="rag-web-$$ACCOUNT_ID-$(AWS_REGION)" && \
	echo "  账号: $$ACCOUNT_ID" && \
	echo "  区域: $(AWS_REGION)" && \
	echo "  S3桶: $$BUCKET_NAME"
	@echo ""
	@echo "2. 部署Web栈..."
	@cd infrastructure && \
		set -a && source ../.env && set +a && \
		CDK_DEFAULT_REGION=$${AWS_REGION} \
		CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) \
		AWS_DEFAULT_REGION=$${AWS_REGION} \
		npx cdk deploy RAG-Web-$(STAGE) \
		--context stage=$(STAGE) \
		--require-approval never \
		--outputs-file web-outputs.json
	@echo ""
	@echo "3. 获取CloudFront信息..."
	@cd infrastructure && \
		if [ -f web-outputs.json ]; then \
			CLOUDFRONT_URL=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontURL', 'N/A'))") && \
			DISTRIBUTION_ID=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontDistributionId', 'N/A'))") && \
			echo "  CloudFront URL: $$CLOUDFRONT_URL" && \
			echo "  Distribution ID: $$DISTRIBUTION_ID"; \
		fi
	@echo ""
	@echo "4. 上传前端文件到S3..."
	@ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text) && \
	BUCKET_NAME="rag-web-$$ACCOUNT_ID-$(AWS_REGION)" && \
	cd app/views/web && \
	aws s3 sync . s3://$$BUCKET_NAME/ \
		--delete \
		--exclude "*.backup" \
		--exclude ".DS_Store" \
		--exclude "templates/*" && \
	aws s3 cp index.html s3://$$BUCKET_NAME/index.html \
		--content-type "text/html" \
		--cache-control "no-cache, no-store, must-revalidate" && \
	aws s3 cp static/js/ s3://$$BUCKET_NAME/static/js/ \
		--recursive \
		--content-type "application/javascript" && \
	aws s3 cp static/css/ s3://$$BUCKET_NAME/static/css/ \
		--recursive \
		--content-type "text/css"
	@echo ""
	@echo "5. 创建CloudFront缓存失效..."
	@cd infrastructure && \
		if [ -f web-outputs.json ]; then \
			DISTRIBUTION_ID=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontDistributionId', 'N/A'))") && \
			if [ "$$DISTRIBUTION_ID" != "N/A" ]; then \
				aws cloudfront create-invalidation \
					--distribution-id $$DISTRIBUTION_ID \
					--paths "/*" --query 'Invalidation.Id' --output text && \
				echo "  缓存失效已创建"; \
			fi; \
		fi
	@echo ""
	@echo "✅ Web栈部署完成！"
	@echo ""
	@echo "📋 后续步骤："
	@echo "  1. 等待1-2分钟让CloudFront缓存失效生效"
	@echo "  2. 访问CloudFront URL查看前端"
	@echo "  3. 如遇到403错误，运行: make fix-cloudfront"
	@echo ""

# 完全重新部署Web栈（彻底修复CloudFront 403）
redeploy-web: check-env
	@echo "🚨 完全重新部署Web栈以修复CloudFront 403根本问题"
	@echo "================================"
	@echo ""
	@echo "此操作将销毁并重新创建CloudFront分发"
	@echo "  - 新的CloudFront URL将会改变"
	@echo "  - 部署需要15-20分钟"
	@echo ""
	@read -p "确认继续？(输入 'yes' 确认): " confirm; \
	if [ "$$confirm" != "yes" ]; then \
		echo "操作已取消"; \
		exit 0; \
	fi
	@echo ""
	@echo "步骤1：销毁现有Web栈..."
	@echo "========================"
	@cd infrastructure && \
		npx cdk destroy RAG-Web-$(STAGE) --force || true
	@echo ""
	@echo "步骤2：等待资源清理..."
	@echo "======================"
	@echo "等待30秒确保资源完全清理..."
	@sleep 30
	@echo ""
	@echo "步骤3：重新部署Web栈..."
	@echo "======================"
	@# 获取API URL（如果存在）
	@API_URL=$$(aws cloudformation describe-stacks \
		--stack-name RAG-API-$(STAGE) \
		--query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
		--output text 2>/dev/null || echo "https://api.example.com") && \
	echo "API URL: $$API_URL" && \
	cd infrastructure && \
		set -a && source ../.env && set +a && \
		CDK_DEFAULT_REGION=$${AWS_REGION} \
		CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) \
		AWS_DEFAULT_REGION=$${AWS_REGION} \
		API_URL=$$API_URL \
		npx cdk deploy RAG-Web-$(STAGE) \
		--app "./venv/bin/python deploy_web_only.py" \
		--context stage=$(STAGE) \
		--context apiUrl=$$API_URL \
		--require-approval never \
		--outputs-file web-outputs.json
	@echo ""
	@echo "步骤4：获取新的CloudFront URL..."
	@echo "================================"
	@cd infrastructure && \
		if [ -f web-outputs.json ]; then \
			NEW_CLOUDFRONT_URL=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontURL', 'N/A'))") && \
			NEW_DISTRIBUTION_ID=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontDistributionId', 'N/A'))") && \
			echo "" && \
			echo "✅ 部署成功！" && \
			echo "" && \
			echo "📋 新的部署信息：" && \
			echo "  CloudFront URL: $$NEW_CLOUDFRONT_URL" && \
			echo "  Distribution ID: $$NEW_DISTRIBUTION_ID" && \
			echo "" && \
			echo "请等待5-10分钟让CloudFront完全部署" && \
			echo "" && \
			echo "$${NEW_CLOUDFRONT_URL}" > cloudfront_url.txt && \
			echo "新的URL已保存到 cloudfront_url.txt"; \
		else \
			echo "❌ 无法获取部署信息"; \
		fi
	@echo ""
	@echo "步骤5：上传前端文件..."
	@echo "===================="
	@ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text) && \
	BUCKET_NAME="rag-web-$$ACCOUNT_ID-$(AWS_REGION)" && \
	echo "上传文件到 S3: $$BUCKET_NAME" && \
	cd app/views/web && \
	aws s3 sync . s3://$$BUCKET_NAME/ \
		--delete \
		--exclude "*.backup" \
		--exclude ".DS_Store" && \
	aws s3 cp index.html s3://$$BUCKET_NAME/index.html \
		--content-type "text/html" \
		--cache-control "no-cache" && \
	aws s3 cp static/css/ s3://$$BUCKET_NAME/static/css/ \
		--recursive \
		--content-type "text/css" && \
	aws s3 cp static/js/ s3://$$BUCKET_NAME/static/js/ \
		--recursive \
		--content-type "application/javascript"
	@echo ""
	@echo "🎉 完成！"
	@echo "========"
	@echo ""
	@echo "CloudFront分发已使用正确的配置重新创建："
	@echo "  ✅ 使用S3 REST API端点"
	@echo "  ✅ 配置了OAI"
	@echo "  ✅ S3桶保持私有"
	@echo "  ✅ 403/404错误正确处理"
	@echo ""
	@echo "请访问新的CloudFront URL测试（等待5-10分钟）"
	@cd infrastructure && \
		if [ -f web-outputs.json ]; then \
			NEW_CLOUDFRONT_URL=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontURL', 'N/A'))") && \
			echo "URL: $$NEW_CLOUDFRONT_URL"; \
		fi
	@$(MAKE) notify

# 修复CloudFront 403错误
fix-cloudfront:
	@echo "🔧 修复CloudFront 403错误..."
	@ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text) && \
	BUCKET_NAME="rag-web-$$ACCOUNT_ID-$(AWS_REGION)" && \
	echo "S3 Bucket: $$BUCKET_NAME"
	@echo ""
	@echo "1. 检查OAI配置..."
	@OAI_ID=$$(aws cloudfront list-cloud-front-origin-access-identities \
		--query "CloudFrontOriginAccessIdentityList.Items[?contains(Comment,'RAG')].Id" \
		--output text | head -1) && \
	if [ -n "$$OAI_ID" ]; then \
		echo "  OAI ID: $$OAI_ID"; \
	else \
		echo "❌ OAI未找到，请先部署Web栈"; \
		exit 1; \
	fi
	@echo ""
	@echo "2. 验证S3文件..."
	@ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text) && \
	BUCKET_NAME="rag-web-$$ACCOUNT_ID-$(AWS_REGION)" && \
	aws s3api head-object --bucket $$BUCKET_NAME --key index.html &>/dev/null && \
		echo "  ✅ index.html存在" || \
		(echo "  ❌ index.html不存在，正在上传..." && \
		cd app/views/web && \
		aws s3 cp index.html s3://$$BUCKET_NAME/index.html \
			--content-type "text/html")
	@echo ""
	@echo "3. 创建CloudFront缓存失效..."
	@cd infrastructure && \
		if [ -f web-outputs.json ]; then \
			DISTRIBUTION_ID=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontDistributionId', 'N/A'))") && \
			if [ "$$DISTRIBUTION_ID" != "N/A" ]; then \
				INVALIDATION_ID=$$(aws cloudfront create-invalidation \
					--distribution-id $$DISTRIBUTION_ID \
					--paths "/*" --query 'Invalidation.Id' --output text) && \
				echo "  缓存失效ID: $$INVALIDATION_ID"; \
			fi; \
		fi
	@echo ""
	@echo "✅ 修复完成！请等待1-2分钟让缓存失效生效"

# 验证Web部署
verify-web:
	@echo "🧪 验证Web部署..."
	@cd infrastructure && \
		if [ -f web-outputs.json ]; then \
			CLOUDFRONT_URL=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontURL', 'N/A'))") && \
			DISTRIBUTION_ID=$$(cat web-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontDistributionId', 'N/A'))") && \
			echo "CloudFront URL: $$CLOUDFRONT_URL" && \
			echo "Distribution ID: $$DISTRIBUTION_ID" && \
			echo "" && \
			echo "检查CloudFront状态..." && \
			STATUS=$$(aws cloudfront get-distribution --id $$DISTRIBUTION_ID --query 'Distribution.Status' --output text) && \
			echo "状态: $$STATUS" && \
			echo "" && \
			echo "测试访问..." && \
			HTTP_CODE=$$(curl -s -o /dev/null -w "%{http_code}" $$CLOUDFRONT_URL) && \
			echo "HTTP响应: $$HTTP_CODE" && \
			if [ "$$HTTP_CODE" = "200" ]; then \
				echo "✅ Web部署验证成功！"; \
			else \
				echo "❌ Web部署验证失败 (HTTP $$HTTP_CODE)"; \
				echo "请运行: make fix-cloudfront"; \
			fi; \
		else \
			echo "❌ web-outputs.json不存在，请先运行: make deploy-web"; \
		fi

# 部署前端到S3（保留兼容性）
deploy-frontend:
	@echo "部署前端到S3..."
	@$(MAKE) deploy-web

# 从.env文件读取变量
-include .env
export

# 部署
deploy: check-env clean package-lambda
	@echo "开始部署 (stage=$(STAGE))..."
	@echo "正在检查并清理CDK进程..."
	@ps aux | grep -E "(cdk|aws-cdk)" | grep -v grep | awk '{print $$2}' | xargs -r kill -9 2>/dev/null || true
	@rm -rf infrastructure/cdk.out
	@echo ""
	@echo "1. 环境配置:"
	@echo "  AWS_REGION: $(AWS_REGION) (来自.env)"
	@echo "  账号: $$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo '需要配置')"
	@echo ""
	@echo "2. 检查AWS凭证和Bootstrap..."
	@if ! aws sts get-caller-identity &>/dev/null; then \
		echo "❌ AWS凭证未配置，请运行: aws configure"; \
		exit 1; \
	fi
	@echo "  ✅ AWS凭证有效"
	@echo ""
	@echo "3. 确保CDK Bootstrap..."
	@ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text) && \
	BOOTSTRAP_BUCKET="cdk-hnb659fds-assets-$$ACCOUNT_ID-$(AWS_REGION)" && \
	if ! aws s3 ls "s3://$$BOOTSTRAP_BUCKET" &>/dev/null; then \
		echo "  ⚠️ Bootstrap未完成，正在修复..."; \
		chmod +x fix_cdk_bootstrap.sh && ./fix_cdk_bootstrap.sh; \
	else \
		echo "  ✅ Bootstrap已完成"; \
	fi
	@echo ""
	@echo "4. 安装CDK依赖..."
	@cd infrastructure && pip3 install -r requirements.txt --quiet
	@echo ""
	@echo "5. 设置CDK环境变量..."
	@export CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) && \
	export CDK_DEFAULT_REGION=$(AWS_REGION) && \
	export AWS_ACCOUNT=$$CDK_DEFAULT_ACCOUNT && \
	export AWS_REGION=$(AWS_REGION) && \
	echo "  CDK_DEFAULT_ACCOUNT=$$CDK_DEFAULT_ACCOUNT" && \
	echo "  CDK_DEFAULT_REGION=$$CDK_DEFAULT_REGION"
	@echo ""
	@echo "6. 合成CloudFormation模板..."
	@cd infrastructure && \
		set -a && source ../.env && set +a && \
		export CDK_DEFAULT_REGION=$${AWS_REGION} && \
		export CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) && \
		export AWS_DEFAULT_REGION=$${AWS_REGION} && \
		npx cdk synth --context stage=$(STAGE)
	@echo ""
	@echo "7. 显示要部署的栈..."
	@cd infrastructure && \
		set -a && source ../.env && set +a && \
		export CDK_DEFAULT_REGION=$${AWS_REGION} && \
		export CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) && \
		export AWS_DEFAULT_REGION=$${AWS_REGION} && \
		npx cdk list --context stage=$(STAGE)
	@echo ""
	@echo "按 y 确认部署，按 n 取消"
	@read -p "确认部署? (y/n): " confirm; \
	if [ "$$confirm" != "y" ]; then \
		echo "部署已取消"; \
		exit 1; \
	fi
	@echo ""
	@echo "8. 开始部署栈（包含修复版Web栈）..."
	@cd infrastructure && \
		set -a && source ../.env && set +a && \
		export CDK_DEFAULT_REGION=$${AWS_REGION} && \
		export CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) && \
		export AWS_DEFAULT_REGION=$${AWS_REGION} && \
		npx cdk deploy --all \
		--context stage=$(STAGE) \
		--require-approval never \
		--concurrency 1 \
		--parameters RAG-API-$(STAGE):BedrockModelId=$${BEDROCK_MODEL_ID} \
		--parameters RAG-API-$(STAGE):EmbeddingModelId=$${EMBEDDING_MODEL_ID} \
		--parameters RAG-API-$(STAGE):ZillizEndpoint=$${ZILLIZ_ENDPOINT} \
		--parameters RAG-API-$(STAGE):ZillizToken=$${ZILLIZ_TOKEN} \
		--outputs-file cdk-outputs.json
	@echo ""
	@echo "9. 创建CloudFront缓存失效..."
	@cd infrastructure && \
		if [ -f cdk-outputs.json ]; then \
			DISTRIBUTION_ID=$$(cat cdk-outputs.json | python3 -c "import json,sys; data=json.load(sys.stdin); print(data.get('RAG-Web-$(STAGE)', {}).get('CloudFrontDistributionId', 'N/A'))" 2>/dev/null || echo "N/A") && \
			if [ "$$DISTRIBUTION_ID" != "N/A" ]; then \
				aws cloudfront create-invalidation \
					--distribution-id $$DISTRIBUTION_ID \
					--paths "/*" --query 'Invalidation.Id' --output text && \
				echo "  缓存失效已创建"; \
			fi; \
		fi
	@echo "✅ 部署完成（已包含CloudFront 403修复）"
	@echo ""
	@echo "部署信息："
	@echo "  API端点: 请查看CDK输出"
	@if [ -n "$${WEB_BUCKET}" ]; then \
		echo "  前端URL: https://$${WEB_BUCKET}.s3.amazonaws.com/index.html"; \
	fi

# 快速部署（跳过确认）
deploy-now: check-env clean package-lambda
	@echo "快速部署模式 (stage=$(STAGE))..."
	@echo "环境: AWS_REGION=$(AWS_REGION)"
	@cd infrastructure && \
		bash -c 'source ../.env && \
		export CDK_DEFAULT_REGION=$${AWS_REGION} && \
		export CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) && \
		export AWS_DEFAULT_REGION=$${AWS_REGION} && \
		npx cdk bootstrap aws://$$CDK_DEFAULT_ACCOUNT/$$CDK_DEFAULT_REGION --context stage=$(STAGE) || true'
	@cd infrastructure && \
		bash -c 'source ../.env && \
		export CDK_DEFAULT_REGION=$${AWS_REGION} && \
		export CDK_DEFAULT_ACCOUNT=$$(aws sts get-caller-identity --query Account --output text) && \
		export AWS_DEFAULT_REGION=$${AWS_REGION} && \
		npx cdk deploy --all \
		--context stage=$(STAGE) \
		--require-approval never \
		--concurrency 1 \
		--parameters RAG-API-$(STAGE):BedrockModelId=$${BEDROCK_MODEL_ID} \
		--parameters RAG-API-$(STAGE):EmbeddingModelId=$${EMBEDDING_MODEL_ID} \
		--parameters RAG-API-$(STAGE):ZillizEndpoint=$${ZILLIZ_ENDPOINT} \
		--parameters RAG-API-$(STAGE):ZillizToken=$${ZILLIZ_TOKEN}'
	@echo "✅ 快速部署完成"

# 销毁资源（CDK管理的资源）
destroy:
	@echo "⚠️  警告: 即将销毁所有AWS资源 (stage=$(STAGE))"
	@read -p "确认销毁? (输入'yes'确认): " confirm && [ "$$confirm" = "yes" ]
	cd infrastructure && npx cdk destroy --all --context stage=$(STAGE) --force
	@echo "✅ CDK资源已销毁"
	@echo ""
	@echo "⚠️  注意: 某些资源可能需要手动清理"
	@echo "  运行 'make destroy-all' 进行完整清理"

# 完全销毁所有资源（包括CDK未管理的）
destroy-all:
	@echo "🚨 警告: 即将完全清理所有AWS资源！"
	@echo "这将删除："
	@echo "  - 所有CloudFormation栈"
	@echo "  - 所有S3存储桶及内容"
	@echo "  - 所有Lambda函数"
	@echo "  - 所有API Gateway"
	@echo "  - 相关IAM角色和策略"
	@echo ""
	@read -p "确认完全销毁? (输入'DELETE ALL'确认): " confirm && [ "$$confirm" = "DELETE ALL" ]
	@chmod +x cleanup_all_resources.sh
	@./cleanup_all_resources.sh
	@echo "✅ 所有资源已完全清理"

# 部署单个栈
deploy-stack:
	@echo "部署单个栈 (stack=$(STACK), stage=$(STAGE))..."
	cd infrastructure && npx cdk deploy $(STACK)-$(STAGE) \
		--context stage=$(STAGE) \
		--require-approval never
	@echo "✅ 栈部署完成"

# 查看日志
logs:
	@echo "查看Lambda日志 (stage=$(STAGE))..."
	aws logs tail /aws/lambda/RAG-Query-$(STAGE) --follow

# 运行本地API
run-local:
	@echo "启动本地API服务器..."
	cd app && python -m uvicorn main:app --reload --host 0.0.0.0 --port 8000

# 构建Docker镜像
docker-build:
	@echo "构建Docker镜像..."
	docker build -t rag-app:latest .
	@echo "✅ Docker镜像构建完成"

# 运行Docker容器
docker-run: docker-build
	@echo "运行Docker容器..."
	docker run -p 8000:8000 \
		-e AWS_REGION=$${AWS_REGION:-us-east-1} \
		-e ZILLIZ_ENDPOINT=$(ZILLIZ_ENDPOINT) \
		-e ZILLIZ_TOKEN=$(ZILLIZ_TOKEN) \
		--rm rag-app:latest

# 完整部署（包含Web修复）
deploy-all: check-env clean package-lambda
	@echo "🚀 完整部署RAG应用..."
	@echo ""
	@echo "1. 部署数据栈..."
	@cd infrastructure && \
		set -a && source ../.env && set +a && \
		npx cdk deploy RAG-Data-$(STAGE) \
		--context stage=$(STAGE) \
		--require-approval never
	@echo ""
	@echo "2. 部署API栈..."
	@cd infrastructure && \
		set -a && source ../.env && set +a && \
		npx cdk deploy RAG-API-$(STAGE) \
		--context stage=$(STAGE) \
		--require-approval never \
		--parameters RAG-API-$(STAGE):BedrockModelId=$${BEDROCK_MODEL_ID} \
		--parameters RAG-API-$(STAGE):EmbeddingModelId=$${EMBEDDING_MODEL_ID} \
		--parameters RAG-API-$(STAGE):ZillizEndpoint=$${ZILLIZ_ENDPOINT} \
		--parameters RAG-API-$(STAGE):ZillizToken=$${ZILLIZ_TOKEN}
	@echo ""
	@echo "3. 部署Web栈（修复版）..."
	@$(MAKE) deploy-web STAGE=$(STAGE)
	@echo ""
	@echo "4. 验证部署..."
	@$(MAKE) verify-web
	@echo ""
	@echo "✅ 完整部署成功！"
	@$(MAKE) notify

# 完整的CI/CD流程
ci: clean install lint type-check test test-coverage
	@echo "✅ CI检查全部通过"

# 部署前准备
prepare: check-env clean synth
	@echo "✅ 部署准备完成"

# 显示当前配置
show-config:
	@echo "当前配置:"
	@echo "  STAGE: $(STAGE)"
	@echo "  AWS_REGION: $${AWS_REGION:-us-east-1}"
	@echo "  BEDROCK_MODEL_ID: $${BEDROCK_MODEL_ID:-amazon.nova-lite-v1:0}"
	@echo "  EMBEDDING_MODEL_ID: $${EMBEDDING_MODEL_ID:-amazon.titan-embed-text-v2:0}"
	@echo "  ZILLIZ_ENDPOINT: $${ZILLIZ_ENDPOINT:0:20}..."

# 开发环境设置
dev-setup: install
	@echo "设置开发环境..."
	@cp .env.example .env 2>/dev/null || true
	@echo "请编辑 .env 文件配置必要的环境变量"
	@echo "✅ 开发环境设置完成"

# 检查项目健康状态
health-check:
	@echo "检查项目健康状态..."
	@python -c "import app; print('✅ App模块可导入')"
	@python -c "import boto3; print('✅ AWS SDK已安装')"
	@python -c "import langchain; print('✅ LangChain已安装')"
	@python -c "import pymilvus; print('✅ Milvus客户端已安装')"
	@echo "✅ 项目健康检查通过"

# 启动所有服务
start-all: docker-run
	@echo "✅ 所有服务已启动"

# 停止所有服务
stop-all:
	@echo "停止所有服务..."
	@docker stop $$(docker ps -q) 2>/dev/null || true
	@pkill -f "uvicorn" 2>/dev/null || true
	@echo "✅ 所有服务已停止"

# 显示项目信息
info:
	@echo "AWS-Zilliz-RAG 项目信息"
	@echo "========================"
	@echo "项目路径: $$(pwd)"
	@echo "Python版本: $$(python3 --version)"
	@echo "Pytest版本: $$(pytest --version | head -1)"
	@echo "AWS CLI版本: $$(aws --version)"
	@echo "CDK版本: $$(cdk --version)"
	@echo ""
	@echo "测试统计:"
	@echo "  单元测试: $$(find tests/unit -name "test_*.py" | wc -l) 个文件"
	@echo "  集成测试: $$(find tests/integration -name "test_*.py" | wc -l) 个文件"
	@echo "  E2E测试: $$(find tests/e2e -name "test_*.py" | wc -l) 个文件"
	@echo ""
	@echo "代码统计:"
	@echo "  Python文件: $$(find app -name "*.py" | wc -l) 个"
	@echo "  代码行数: $$(find app -name "*.py" -exec wc -l {} + | tail -1 | awk '{print $$1}') 行"

# 完成提示音
notify:
	@afplay /System/Library/Sounds/Sosumi.aiff

# 带通知的部署
deploy-notify: deploy notify
	@echo "✅ 部署完成并已发送通知"

# 带通知的测试
test-notify: test notify
	@echo "✅ 测试完成并已发送通知"